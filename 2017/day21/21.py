def parseGrid(g):
    tmp = []
    currRow = []
    for ch in g:
        if ch != '/':
            currRow.append(replace(ch))
        else:
            tmp.append(currRow)
            currRow = []
    tmp.append(currRow)
    return tmp

def refl(g): #horizontal flip
        return tuple(reversed(g))
def rotn(g): # 90 degree rotation
    newG = []
    for i in range(len(g)):
        newG.append(tuple(reversed([x[i] for x in g])))
    return tuple(newG)

# symmetry group of a square is generated by a rotation and reflection:
# Given reflection f and rotation r, the full set of symmetries of a square is:
# g, r(g), r^2(g), r^3(g), f(g), f(r(g)), f(r^2(g)), f(r^3(g))
def symmetries(g):
    syms = [tuple([tuple(x) for x in g])]
    for i in range(3):
        syms.append(rotn(syms[-1]))
    for i in range(4):
        syms.append(refl(syms[i]))
    return syms
replace = lambda x: 1 if x == "#" else 0

def makeRules(lines):
    rules = {}
    for l in lines:
        pattern, res = l.split(' => ')
        pattern = parseGrid(pattern)
        res = parseGrid(res)
        for p in symmetries(pattern):
            rules[p] = res
    return rules

def updateGrid(g, rules):
    newG = []
    step = 3 if len(g) % 2 else 2

    for i in range(len(g) // step):
        newRow = [[None] for i in range(step + 1)]
        for j in range(len(g) // step):
            key = tuple(tuple(x[step*j:step*(j+1)]) for x in g[step*i:step*(i+1)])
            val = rules[key]
            for k in range(step + 1):
                newRow[k] += val[k]
        newRow = [x[1:] for x in newRow]
        newG += newRow
    return newG

if __name__ == "__main__":
    s = open('input.txt','r').read().split('\n')
    rules = makeRules(s)
    pattern = [[0,1,0],[0,0,1],[1,1,1]]
    iterCount = 18
    for i in range(iterCount):
        pattern = updateGrid(pattern, rules)
        if i == 4:
            print("Part 1:", sum(sum(x) for x in pattern))
    print("Part 2:", sum(sum(x) for x in pattern))

